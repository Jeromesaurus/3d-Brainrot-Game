<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Choice Runner</title>
    <!-- Load Tailwind CSS --><script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load Tone.js (Audio library) --><script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    
    <!-- Add Import Map to define module paths -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
        }
    }
    </script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrolling */
        }
        /* Style for the 3D canvas */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* UI overlay elements */
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through to canvas/controls */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }
        /* Score display */
        #score {
            margin-top: 2rem;
            font-size: 3rem;
            font-weight: bold;
            color: black; /* Changed to black for white background */
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); /* Adjusted for light background */
        }
        /* Modal for start/game over */
        .modal {
            pointer-events: all; /* Modals should be interactive */
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        /* Center the modal */
        #modal-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        /* Fun, modern button style */
        .game-button {
            background-image: linear-gradient(to right, #4ade80, #3b82f6);
            color: white;
            font-weight: bold;
            font-size: 1.25rem;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .game-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        .game-button:active {
            transform: translateY(0);
        }
        /* Style for file inputs */
        input[type="file"]::file-selector-button {
            background-image: linear-gradient(to right, #4ade80, #3b82f6);
            color: white;
            font-weight: bold;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }
    </style>
</head>
<body class="bg-gray-900">

    <!-- 3D scene will be injected here --><div id="game-container" class="absolute top-0 left-0 w-full h-full"></div>

    <!-- UI Overlay --><div id="ui-container">
        <!-- Score --><div id="score" class="hidden">Score: 0</div>
    </div>

    <!-- Start/Game Over Modal --><div id="modal-container">
        
        <!-- Mode Select Modal -->
        <div id="mode-select-modal" class="modal">
            <h1 class="text-4xl font-bold text-white mb-2">3D Choice Runner</h1>
            <p class="text-lg text-gray-200 mb-4">Choose your mode:</p>
            <button id="normal-mode-btn" class="game-button">Normal Mode</button>
            <button id="custom-mode-btn" class="game-button mt-4">Custom Mode</button>
        </div>

        <!-- Custom Game Setup -->
        <div id="custom-game-modal" class="modal hidden" style="width: 500px; max-width: 90vw;">
            <h1 class="text-3xl font-bold text-white mb-4">Custom Game Setup</h1>
            <div id="image-pairs-list" class="w-full h-48 bg-gray-800 rounded-lg p-2 overflow-y-auto mb-4">
                <p class="text-gray-400">No image pairs added yet.</p>
            </div>
            <button id="add-pair-btn" class="game-button">Add Image Pair</button>
            <button id="start-custom-game-btn" class="game-button mt-4 opacity-50" disabled>Start Custom Game</button>
            <button id="back-to-mode-btn" class="text-gray-400 mt-2 text-sm">Back to Main Menu</button>
        </div>

        <!-- Add Image Pair -->
        <div id="add-image-modal" class="modal hidden" style="width: 600px; max-width: 90vw;">
            <h1 class="text-3xl font-bold text-white mb-4">Add Image Pair</h1>
            <div class="flex flex-col md:flex-row justify-around gap-4">
                <!-- Correct Image -->
                <div class="flex-1">
                    <h2 class="text-xl font-bold text-green-400 mb-2">Correct Image</h2>
                    <input type="file" id="correct-image-input" accept="image/*" class="text-white w-full">
                    <img id="correct-image-preview" src="https://placehold.co/200x200/333/888?text=Correct" class="w-full h-48 object-cover rounded-lg mt-2">
                </div>
                <!-- Wrong Image -->
                <div class="flex-1">
                    <h2 class="text-xl font-bold text-red-400 mb-2">Wrong Image</h2>
                    <input type="file" id="wrong-image-input" accept="image/*" class="text-white w-full">
                    <img id="wrong-image-preview" src="https://placehold.co/200x200/333/888?text=Wrong" class="w-full h-48 object-cover rounded-lg mt-2">
                </div>
            </div>
            <button id="save-pair-btn" class="game-button mt-6">Save Pair</button>
            <button id="cancel-add-pair-btn" class="text-gray-400 mt-2 text-sm">Cancel</button>
        </div>
        
        <!-- Game Over Modal -->
        <div id="game-over-modal" class="modal hidden">
            <h1 id="game-over-title" class="text-4xl font-bold text-white mb-2">Game Over!</h1>
            <p class="text-2xl text-gray-200 mb-4">Final Score: <span id="final-score">0</span></p>
            <button id="restart-button" class="game-button">Play Again</button>
            <button id="main-menu-btn" class="text-gray-400 mt-2 text-sm">Main Menu</button>
        </div>
    </div>

    <script type="module">
        // Import THREE and GLTFLoader from the importmap
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- Global Variables ---
        let scene, camera, renderer, clock, textureLoader;
        let player, playerTargetX;
        let ground;
        let lanes = [];
        let feedbackIcons = []; // For checkmarks and X's
        let score = 0;
        let gameSpeed = 10;
        let gameState = 'menu'; // 'menu', 'playing', 'gameover'
        let audioInitialized = false;
        let isPlayerLoaded = false; // Flag to ensure player model is loaded before starting

        // --- New Mode Variables ---
        let customImages = []; // Will store {correct: Texture, wrong: Texture}
        let isCustomMode = false; // Flag for game mode

        // --- Game Constants ---
        const laneWidth = 3; // X position for left/right lanes
        const spawnDistance = -100; // How far ahead gates spawn
        const safeZone = 1; // Z-distance from player to check collision
        const laneCheckTolerance = 0.5; // How close player must be to lane center
        const TOTAL_GATES = 10; // Total number of gates before the finish line
        const GATE_SPACING = 15; // Spacing between gates
        const CAMERA_Z_OFFSET = 12; // How far camera is behind player
        
        let totalGatesSpawned = 0;
        let finishLine = null;

        // --- UI Elements ---
        const scoreElement = document.getElementById('score');
        const gameOverModal = document.getElementById('game-over-modal');
        const restartButton = document.getElementById('restart-button');
        const finalScoreElement = document.getElementById('final-score');
        const gameContainer = document.getElementById('game-container');
        const gameOverTitle = document.getElementById('game-over-title');
        
        // New UI Elements
        const modeSelectModal = document.getElementById('mode-select-modal');
        const customGameModal = document.getElementById('custom-game-modal');
        const addImageModal = document.getElementById('add-image-modal');
        const normalModeBtn = document.getElementById('normal-mode-btn');
        const customModeBtn = document.getElementById('custom-mode-btn');
        const addPairBtn = document.getElementById('add-pair-btn');
        const startCustomGameBtn = document.getElementById('start-custom-game-btn');
        const backToModeBtn = document.getElementById('back-to-mode-btn');
        const savePairBtn = document.getElementById('save-pair-btn');
        const cancelAddPairBtn = document.getElementById('cancel-add-pair-btn');
        const correctImageInput = document.getElementById('correct-image-input');
        const wrongImageInput = document.getElementById('wrong-image-input');
        const correctImagePreview = document.getElementById('correct-image-preview');
        const wrongImagePreview = document.getElementById('wrong-image-preview');
        const imagePairsList = document.getElementById('image-pairs-list');
        const mainMenuBtn = document.getElementById('main-menu-btn');


        // --- Audio Components (Tone.js) ---
        let synth, musicLoop;
        let sfxSynth; // Synth for sound effects

        // --- Core Functions ---

        /**
         * Initialize the entire 3D scene, renderer, camera, and lights
         */
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff); // White background
            scene.fog = new THREE.Fog(0xffffff, 10, 150); // White fog

            // Clock
            clock = new THREE.Clock();
            textureLoader = new THREE.TextureLoader(); // Initialize texture loader

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 7, CAMERA_Z_OFFSET); // Use constant for Z offset
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            gameContainer.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8); // Brighter ambient
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5); // Brighter directional light
            dirLight.position.set(10, 20, 5);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 10;
            dirLight.shadow.camera.bottom = -10;
            dirLight.shadow.camera.left = -10;
            dirLight.shadow.camera.right = 10;
            scene.add(dirLight);

            // Create Game Objects
            createPlayer(); // This now initiates loading the model
            createGround(); // Create the static ground
            
            // Create static gates and finish line (will be reset in startGame)
            createAllGameElements();

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            // Touch controls
            document.addEventListener('touchstart', onTouchStart, { passive: false });
            document.addEventListener('touchend', onTouchEnd, { passive: false });
            
            // UI Button Listeners
            normalModeBtn.addEventListener('click', () => startGame(false));
            customModeBtn.addEventListener('click', showCustomMenu);
            addPairBtn.addEventListener('click', showAddPairModal);
            cancelAddPairBtn.addEventListener('click', hideAddPairModal);
            backToModeBtn.addEventListener('click', showModeSelect);
            correctImageInput.addEventListener('change', (e) => handleImagePreview(e, correctImagePreview));
            wrongImageInput.addEventListener('change', (e) => handleImagePreview(e, wrongImagePreview));
            savePairBtn.addEventListener('click', saveImagePair);
            startCustomGameBtn.addEventListener('click', () => startGame(true));
            mainMenuBtn.addEventListener('click', showModeSelect);
            restartButton.addEventListener('click', restartGame);


            // Start animation loop
            animate();
        }

        // --- UI Navigation Functions ---

        function showCustomMenu() {
            modeSelectModal.classList.add('hidden');
            customGameModal.classList.remove('hidden');
        }

        function showAddPairModal() {
            addImageModal.classList.remove('hidden');
            // Reset previews
            correctImageInput.value = null;
            wrongImageInput.value = null;
            correctImagePreview.src = 'https://placehold.co/200x200/333/888?text=Correct';
            wrongImagePreview.src = 'https://placehold.co/200x200/333/888?text=Wrong';
        }

        function hideAddPairModal() {
            addImageModal.classList.add('hidden');
        }

        function showModeSelect() {
            gameOverModal.classList.add('hidden');
            customGameModal.classList.add('hidden');
            modeSelectModal.classList.remove('hidden');
            
            // Clear custom game setup on exit
            customImages.forEach(pair => {
                pair.correct.dispose();
                pair.wrong.dispose();
            });
            customImages = []; 
            imagePairsList.innerHTML = '<p class="text-gray-400">No image pairs added yet.</p>';
            startCustomGameBtn.classList.add('opacity-50');
            startCustomGameBtn.disabled = true;
        }

        // --- Custom Mode Image Handling ---

        function handleImagePreview(event, previewElement) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                previewElement.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function saveImagePair() {
            const correctDataURL = correctImagePreview.src;
            const wrongDataURL = wrongImagePreview.src;

            // Check if images are still placeholders
            if (correctDataURL.startsWith('https://placehold') || wrongDataURL.startsWith('https://placehold')) {
                console.warn("Please select both a correct and a wrong image.");
                // We could show a UI error here
                return;
            }

            // Pre-load textures and store them
            const correctTexture = textureLoader.load(correctDataURL);
            const wrongTexture = textureLoader.load(wrongDataURL);
            
            customImages.push({ correct: correctTexture, wrong: wrongTexture });
            
            updateImagePairsList(correctDataURL, wrongDataURL);
            hideAddPairModal();

            // Enable start button
            startCustomGameBtn.classList.remove('opacity-50');
            startCustomGameBtn.disabled = false;
        }

        function updateImagePairsList(correctDataURL, wrongDataURL) {
            if (customImages.length === 1) {
                imagePairsList.innerHTML = ''; // Clear "No image pairs" message
            }
            
            // Add a visual representation of the pair to the list
            imagePairsList.innerHTML += `
                <div class="flex items-center p-1 bg-gray-700 rounded mb-1">
                    <img src="${correctDataURL}" class="w-10 h-10 rounded object-cover" alt="Correct">
                    <span class="text-green-400 mx-2 font-bold">VS</span>
                    <img src="${wrongDataURL}" class="w-10 h-10 rounded object-cover" alt="Wrong">
                </div>
            `;
        }

        // --- Game Logic Functions ---

        /**
         * Start the game logic and audio
         */
        async function startGame(isCustom = false) {
            isCustomMode = isCustom; // Set game mode

            if (!isPlayerLoaded) {
                console.warn("Player model not yet loaded. Please wait.");
                return;
            }
            
            if (isCustomMode && customImages.length === 0) {
                console.warn("No custom images loaded. Cannot start custom game.");
                // We could show a UI error here
                return;
            }


            // Initialize audio on first user gesture
            if (!audioInitialized) {
                await Tone.start();
                initAudio();
                audioInitialized = true;
                console.log("Audio Initialized");
            }
            
            // Reset state
            score = 0;
            gameSpeed = 10;
            playerTargetX = 0; // Start in the middle
            
            // Reset player position
            player.position.set(0, 1.5, 0); // Reset player position above platform (raised)
            
            // Reset camera position
            camera.position.set(0, 7, CAMERA_Z_OFFSET);
            
            gameState = 'playing';

            // Clear old icons and recreate all game elements
            feedbackIcons.forEach(icon => scene.remove(icon));
            feedbackIcons = [];
            
            createAllGameElements(); // Re-create gates and finish line

            // Update UI
            scoreElement.textContent = `Score: 0`;
            scoreElement.classList.remove('hidden');
            modeSelectModal.classList.add('hidden'); // Hide mode select
            customGameModal.classList.add('hidden'); // Hide custom setup
            gameOverModal.classList.add('hidden'); // Hide game over
            
            // Start music
            if (musicLoop) {
                musicLoop.stop(); // Stop loop first to prevent conflicts
                musicLoop.start(Tone.Transport.nextTickTime);
            }
        }
        
        /**
         * Wipes and recreates all lanes and the finish line.
         */
        function createAllGameElements() {
            // Clear old lanes and finish line
            lanes.forEach(lane => {
                scene.remove(lane.group);
                // TODO: Add proper disposal of geometries and materials here
            });
            lanes = [];
            if (finishLine) {
                scene.remove(finishLine);
                finishLine = null;
            }
            totalGatesSpawned = 0;

            // Create a fixed set of lanes
            for(let i = 0; i < TOTAL_GATES; i++) {
                createLanePair(i * GATE_SPACING); // Spawn lanes progressively further
                totalGatesSpawned++;
            }
            
            // Create the finish line after the last gate
            createFinishLine();
        }
        
        /**
         * Restart the game (wrapper for startGame)
         */
        function restartGame() {
            // Restart in the *current* mode
            setTimeout(() => startGame(isCustomMode), 100);
        }

        /**
         * Handle game over state
         */
        function handleGameOver() {
            gameState = 'gameover';
            
            // Play sound
            if(audioInitialized && musicLoop) {
                sfxSynth.triggerAttackRelease("G2", "4n"); // Use sfxSynth
                musicLoop.stop();
            }
            
            // Update UI
            finalScoreElement.textContent = score;
            gameOverModal.classList.remove('hidden');
            scoreElement.classList.add('hidden');
        }

        /**
         * Handle game win state
         */
        function handleGameWin() {
            gameState = 'gameover'; // Use same state to show modal
            
            // Play sound
            if(audioInitialized && musicLoop) {
                sfxSynth.triggerAttackRelease("C5", "1n"); // A long, happy note
                musicLoop.stop();
            }
            
            // Update UI
            gameOverTitle.textContent = "You Win!"; // Change title
            finalScoreElement.textContent = score;
            gameOverModal.classList.remove('hidden');
            scoreElement.classList.add('hidden');
        }

        /**
         * Initialize Tone.js components (synth and music)
         */
        function initAudio() {
            // Simple synth for music
            synth = new Tone.Synth().toDestination();
            // Separate synth for sound effects to avoid timing conflicts
            sfxSynth = new Tone.Synth().toDestination();

            // Background music loop
            const notes = ["C3", "E3", "G3", "B3", "C4", "E4", "G4", "B4"];
            let noteIndex = 0;
            musicLoop = new Tone.Loop(time => {
                if (synth) {
                   synth.triggerAttackRelease(notes[noteIndex % notes.length], "16n", time);
                   noteIndex++;
                }
            }, "16n");
            
            Tone.Transport.bpm.value = 130;
            Tone.Transport.start();
        }

        /**
         * Create the player character by loading a GLB model.
         */
        function createPlayer() {
            const loader = new GLTFLoader();
            const modelPath = 'https://cdn.jsdelivr.net/gh/Jeromesaurus/3d-Brainrot-Game@eb6eaf963884ce06456ea9ec34d8b8ed0793f480/assets/model/tung_tung_sahur.glb';

            loader.load(
                modelPath,
                function (gltf) {
                    player = gltf.scene;
                    player.scale.set(2.0, 2.0, 2.0); 
                    player.position.set(0, 1.5, 0); // Raised Y position
                    player.rotation.y = Math.PI;
                    player.traverse(function(child) {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    scene.add(player);
                    isPlayerLoaded = true;
                },
                undefined, // onProgress callback not needed
                function (error) {
                    console.error('An error occurred while loading the player model:', error);
                    // Fallback to a simple cylinder if model loading fails
                    const playerGeo = new THREE.CylinderGeometry(0.5, 0.5, 2, 16);
                    const playerMat = new THREE.MeshStandardMaterial({ color: 0x3b82f6 });
                    player = new THREE.Mesh(playerGeo, playerMat);
                    player.position.set(0, 1, 0);
                    player.castShadow = true;
                    scene.add(player);
                    isPlayerLoaded = true; // Mark as loaded even if fallback
                }
            );
            playerTargetX = 0;
        }

        /**
         * Create the endless ground plane
         */
        function createGround() {
            const lastGateZPos = spawnDistance - ((TOTAL_GATES - 1) * GATE_SPACING);
            const finishLineZ = lastGateZPos - GATE_SPACING - 20;
            const startZ = 20; 
            const groundLength = Math.abs(finishLineZ - startZ) + 40;
            const groundCenterZ = (startZ + finishLineZ) / 2;
            
            const canvas = document.createElement('canvas');
            const roadWidthPixels = 64;
            const roadSegmentPixels = 64;
            canvas.width = roadWidthPixels;
            canvas.height = roadSegmentPixels;
            const context = canvas.getContext('2d');
            
            context.fillStyle = '#660000'; // Darker Red
            context.fillRect(0, 0, roadWidthPixels, roadSegmentPixels);
            
            context.fillStyle = '#ffffff';
            const linePixelWidth = 2;
            const edgePadding = 4; 
            context.fillRect(edgePadding, 0, linePixelWidth, roadSegmentPixels);
            context.fillRect(roadWidthPixels - edgePadding - linePixelWidth, 0, linePixelWidth, roadSegmentPixels);
            
            const dashPixelWidth = 4;
            const dashPixelLength = roadSegmentPixels / 2;
            context.fillRect(roadWidthPixels / 2 - dashPixelWidth / 2, 0, dashPixelWidth, dashPixelLength);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            const textureRepeats = groundLength / 4;
            texture.repeat.set(1, textureRepeats); 
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            texture.magFilter = THREE.LinearFilter;
            
            const groundGeo = new THREE.PlaneGeometry(10, groundLength);
            const groundMat = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.8 });

            if (ground) {
                scene.remove(ground);
            }

            ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.set(0, 0, groundCenterZ);
            ground.receiveShadow = true;
            scene.add(ground);
        }

        /**
         * Create a pair of choice gates (left and right)
         * @param {number} zOffset - How far from the origin to spawn this pair
         */
        function createLanePair(zOffset = 0) {
            const group = new THREE.Group();
            const isRightCorrect = Math.random() > 0.5;
            
            let leftGateMesh, rightGateMesh;

            if (isCustomMode) {
                // --- CUSTOM MODE: Use Images ---
                const pair = customImages[Math.floor(Math.random() * customImages.length)];
                const imgMatCorrect = new THREE.MeshBasicMaterial({ map: pair.correct, side: THREE.DoubleSide });
                const imgMatWrong = new THREE.MeshBasicMaterial({ map: pair.wrong, side: THREE.DoubleSide });
                
                const gateGeo = new THREE.PlaneGeometry(laneWidth * 1.8, 4); // Flat plane
                
                leftGateMesh = new THREE.Mesh(gateGeo, isRightCorrect ? imgMatWrong : imgMatCorrect);
                rightGateMesh = new THREE.Mesh(gateGeo, isRightCorrect ? imgMatCorrect : imgMatWrong);

            } else {
                // --- NORMAL MODE: Use Colors ---
                const correctGateMat = new THREE.MeshStandardMaterial({ color: 0x22c55e, roughness: 0.7, metalness: 0.1 }); // Green
                const wrongGateMat = new THREE.MeshStandardMaterial({ color: 0xef4444, roughness: 0.7, metalness: 0.1 }); // Red
                
                const gateGeo = new THREE.BoxGeometry(laneWidth * 1.8, 4, 0.2); // 3D box
                
                leftGateMesh = new THREE.Mesh(gateGeo, isRightCorrect ? wrongGateMat : correctGateMat);
                rightGateMesh = new THREE.Mesh(gateGeo, isRightCorrect ? correctGateMat : wrongGateMat);
            }

            leftGateMesh.position.y = 2; // height / 2
            rightGateMesh.position.y = 2; // height / 2

            leftGateMesh.castShadow = false; // Optimization: Remove shadow
            rightGateMesh.castShadow = false; // Optimization: Remove shadow

            const leftGate = new THREE.Group();
            const rightGate = new THREE.Group();
            
            leftGate.add(leftGateMesh);
            rightGate.add(rightGateMesh);
            
            leftGate.position.x = -laneWidth;
            rightGate.position.x = laneWidth;
            
            leftGate.position.y = 0.1;
            rightGate.position.y = 0.1;
            
            // Store data for collision detection
            leftGate.userData = { isCorrect: !isRightCorrect, collided: false }; 
            rightGate.userData = { isCorrect: isRightCorrect, collided: false }; 

            group.add(leftGate);
            group.add(rightGate);
            
            group.position.z = spawnDistance - zOffset;
            
            scene.add(group);
            lanes.push({ group, leftGate, rightGate, collided: false });
        }
        
        /**
         * Create the finish line
         */
        function createFinishLine() {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const context = canvas.getContext('2d');
            
            context.fillStyle = 'white';
            context.fillRect(0, 0, 16, 16);
            context.fillStyle = 'black';
            context.fillRect(0, 0, 8, 8);
            context.fillRect(8, 8, 8, 8);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(10, 2);
            texture.magFilter = THREE.NearestFilter;

            const finishGeo = new THREE.PlaneGeometry(laneWidth * 4, 4);
            const finishMat = new THREE.MeshStandardMaterial({ map: texture, side: THREE.DoubleSide });
            
            finishLine = new THREE.Mesh(finishGeo, finishMat);
            
            const lastGateZPos = spawnDistance - ((TOTAL_GATES - 1) * GATE_SPACING);
            const finishLineZ = lastGateZPos - GATE_SPACING - 20;

            finishLine.position.set(0, 0.1, finishLineZ); 
            finishLine.rotation.x = -Math.PI / 2;
            finishLine.receiveShadow = true;
            finishLine.userData = { collided: false };
            scene.add(finishLine);
        }

        /**
         * Creates a text-based sprite (e.g., ✓ or ✗)
         */
        function createFeedbackSprite(text, color) {
            const canvas = document.createElement('canvas');
            const size = 64;
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');
            
            context.fillStyle = 'rgba(0, 0, 0, 0)';
            context.fillRect(0, 0, size, size);
            
            context.font = 'bold 50px Arial';
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, size / 2, size / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ 
                map: texture, 
                transparent: true,
                depthTest: false // Render on top
            });
            
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(3, 3, 1);
            return sprite;
        }


        /**
         * The main animation loop, called every frame
         */
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            // Only run game logic if playing and player model is loaded
            if (gameState === 'playing' && isPlayerLoaded) {
                
                // --- Player Movement (X - Horizontal) ---
                player.position.x = THREE.MathUtils.lerp(player.position.x, playerTargetX, deltaTime * 10);
                
                // --- Player Movement (Z - Forward) ---
                player.position.z -= gameSpeed * deltaTime;
                
                // --- Lane Movement & Logic ---
                for (let i = lanes.length - 1; i >= 0; i--) {
                    const lane = lanes[i];

                    // --- Collision Detection ---
                    if (!lane.collided && lane.group.position.z > player.position.z - safeZone) { 
                        
                        let chosenGate = null;
                        let isCorrect = false;
                        let feedbackX = player.position.x; 

                        if (Math.abs(player.position.x - (-laneWidth)) < laneCheckTolerance) {
                            chosenGate = lane.leftGate;
                            feedbackX = lane.leftGate.parent.position.x;
                        } 
                        else if (Math.abs(player.position.x - laneWidth) < laneCheckTolerance) {
                            chosenGate = lane.rightGate;
                            feedbackX = lane.rightGate.parent.position.x;
                        }

                        if (chosenGate || Math.abs(player.position.x) < laneCheckTolerance) {
                             lane.collided = true;
                             let gateMeshToHide = null;
                             
                            if (chosenGate && chosenGate.userData.isCorrect) {
                                // --- CORRECT ---
                                score++;
                                gameSpeed += 0.2; 
                                if(audioInitialized) sfxSynth.triggerAttackRelease("C5", "16n"); // Removed Tone.now()
                                isCorrect = true;
                                chosenGate.userData.collided = true;
                                gateMeshToHide = chosenGate;
                            } else {
                                // --- WRONG ---
                                score = Math.max(0, score - 1); 
                                if(audioInitialized) sfxSynth.triggerAttackRelease("G3", "8n"); // Removed Tone.now()
                                isCorrect = false;
                                
                                if (chosenGate) {
                                    chosenGate.userData.collided = true;
                                    gateMeshToHide = chosenGate;
                                }
                            }
                            
                            scoreElement.textContent = `Score: ${score}`;

                            // --- Create Feedback Icon ---
                            const text = isCorrect ? '✓' : '✗';
                            const color = isCorrect ? '#22c55e' : '#ef4444'; // Green or Red
                            const feedbackIcon = createFeedbackSprite(text, color);
                            
                            feedbackIcon.position.set(
                                feedbackX,
                                5, // Start 5 units up
                                lane.group.position.z // At the gate's z-depth
                            );
                            
                            scene.add(feedbackIcon);
                            feedbackIcons.push(feedbackIcon);

                            // --- Make ONLY the chosen gate disappear ---
                            if (gateMeshToHide) {
                                // Find the mesh inside the group and hide it
                                gateMeshToHide.children.forEach(child => child.visible = false);
                            }
                        }
                    }
                    
                    // --- Lane Cleanup ---
                    if (lane.group.position.z > player.position.z + 20) {
                        lane.leftGate.children.forEach(child => {
                            if (child.isMesh) {
                                child.geometry.dispose();
                                if (child.material.map) child.material.map.dispose();
                                child.material.dispose();
                            }
                        });
                        lane.rightGate.children.forEach(child => {
                            if (child.isMesh) {
                                child.geometry.dispose();
                                if (child.material.map) child.material.map.dispose();
                                child.material.dispose();
                            }
                        });
                        scene.remove(lane.group);
                        lanes.splice(i, 1);
                    }
                }

                // --- Animate Feedback Icons ---
                for (let i = feedbackIcons.length - 1; i >= 0; i--) {
                    const icon = feedbackIcons[i];
                    icon.position.y += 3 * deltaTime; // Move up
                    icon.material.opacity -= 1.5 * deltaTime; // Fade out
                    
                    if (icon.material.opacity <= 0) {
                        icon.material.dispose();
                        icon.material.map.dispose();
                        scene.remove(icon);
                        feedbackIcons.splice(i, 1);
                    }
                }
                
                // --- Finish Line Logic ---
                if (finishLine) {
                    if (gameState === 'playing' && !finishLine.userData.collided && finishLine.position.z > player.position.z - safeZone && finishLine.position.z < player.position.z + safeZone) {
                        finishLine.userData.collided = true;
                        handleGameWin();
                    }
                }
                
                // --- Check for game end (backup) ---
                if (lanes.length === 0 && !finishLine && totalGatesSpawned >= TOTAL_GATES && gameState === 'playing') {
                    handleGameOver();
                }

                // --- Camera Follow ---
                camera.position.x = 0;
                camera.position.z = player.position.z + CAMERA_Z_OFFSET;
                camera.lookAt(0, 2, player.position.z);
            }
            
            // Always render the scene
            renderer.render(scene, camera);
        }

        // --- Event Handlers ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            if (gameState !== 'playing') return;

            if (event.code === 'ArrowLeft' || event.code === 'KeyA') {
                playerTargetX = -laneWidth;
            } else if (event.code === 'ArrowRight' || event.code === 'KeyD') {
                playerTargetX = laneWidth;
            }
        }
        
        let touchStartPos = null;
        
        function onTouchStart(event) {
            if (gameState !== 'playing') return;
            touchStartPos = { 
                x: event.touches[0].clientX,
                y: event.touches[0].clientY
            };
        }

        function onTouchEnd(event) {
            if (gameState !== 'playing' || !touchStartPos) return;
            
            const touchEndPos = {
                x: event.changedTouches[0].clientX,
                y: event.changedTouches[0].clientY
            };
            
            const deltaX = touchEndPos.x - touchStartPos.x;
            const deltaY = touchEndPos.y - touchStartPos.y;

            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) { 
                if (deltaX < 0) { // Swipe Left
                    playerTargetX = -laneWidth;
                } else { // Swipe Right
                    playerTargetX = +laneWidth;
                }
            }
            
            touchStartPos = null; // Reset start position
        }

// --- Start the game ---
init();
</script>
</body>
</html>

